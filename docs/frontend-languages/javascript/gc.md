# 垃圾回收

## 前置概念

### 内存管理

内存管理指申请内存空间、使用内存空间和释放内存空间的这一系列步骤。

JavaScript 不能像 C 或 C++ 那样由开发者主动调用 API 来完成内存管理，而是使用垃圾回收机制来自动管理内存，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。

### 何为垃圾

在 JavaScript 中以下两种对象数据被定义为垃圾：

* 对象不再被引用时就是垃圾。
* 对象不能**从根上访问到**时就是垃圾（对象不是可达对象 === 垃圾）。

### 可达对象

在谈到 JavaScript 的垃圾回收时，「可达对象」这个名词会经常提及，那么什么是可达对象呢？

* 可以访问到的对象就是可达对象（通过引用、作用域链可以查找到）。
* 可达的标准就是从根出发是否能够被找到。
* JavaScript 中的根可以理解为是全局变量对象（全局执行上下文）。

在清楚上述这些前置概念后，就可以进入正文了。

## GC 算法

### GC 里的垃圾

GC（Garbage Collection）是垃圾回收机制的简写，它可以查找内存中的垃圾、释放空间和回收空间。在 GC 中，有两种判定为垃圾的标准（当作垃圾 ≠ 被回收）：

* 程序中不再需要使用的对象

```javascript
function func() {
  // 没有声明变量的关键字，name 被挂载在当前的 Window 对象下
  name = 'peter';
  return `${name} is a dog.`;
}

func();
```

* 程序中不能再访问到的对象

```javascript
function func() {
  // 增加声明变量的关键字，当函数调用结束后，在外部空间就不能访问到 name 了
  const name = 'peter';
  return `${name} is a dog.`;
}

func();
```

在垃圾回收器进行工作的时候，如何查找垃圾、怎样释放空间、回收空间时如何进行分配，这一系列过程中遵循的规则，就是 GC 算法。

常见的 GC 算法有：

* 引用计数：通过一个数字判断当前对象是不是垃圾。
* 标记清除：在 GC 工作时给活动对象添加一个标记，来判断它是否是一个垃圾。
* 标记整理：同标记清除，但在后续回收过程中可以做一些不同的事情。
* 分代回收：V8 中的回收机制。

下面分别讲一下这几种常见算法的实现原理。

### 引用计数算法实现原理

核心思想：在内部通过一个引用计数器，维护当前对象的引用数。在引用关系改变时修改引用计数器的数字。当这个数值为 0 的时候，GC 开始工作，将其所在的对象空间进行回收和释放。

引用计数算法优点：

* 可以即时回收垃圾对象
* 最大限度减少程序卡顿时间（能尽可能保证内存不会有占满的时候）

引用计数算法缺点：

* 无法回收循环引用的对象
```javascript
function fn() {
  const obj1 = {};
  const obj2 = {};
  obj1.name = obj2;
  obj2.name = obj1;
  return 'peter is a dog.';
}

// 函数调用完后，虽然全局作用域内找不到 obj1 和 obj2
// 但由于他们两者之间有互相指引关系，所以引用计数器数值不为 0，因此空间无法回收
fn()
```
* 资源消耗较大（需要时刻监控当前对象的引用数值）

### 标记清除算法实现原理

核心思想：将整个垃圾回收操作分成「标记」和「清除」二个阶段完成。

第一个阶段会遍历所有对象，找出活动对象（可达对象）并标记。第二个阶段仍是遍历所有对象，清除没有标记的对象，同时消除在第一阶段设置的标记，便于 GC 下一次的正常工作。

经过两个阶段的遍历行为，可以回收相应的空间，交给空闲列表维护以供后续的程序代码使用。

标记清除算法优点：

* 可以回收循环引用的对象（例如函数局部作用域内互相引用的变量，当函数调用结束之后，局部空间的变量失去了与全局空间在作用域上的连接，成为了不可达对象，在标记阶段就无法完成标记，在清除阶段会被清除）

标记清除算法缺点：

* 容易产生碎片化空间，浪费空间（由于当前所回收的垃圾对象在地址上本身是不连续的，在回收之后它们会分散在各个角落，后续使用的时候如果新的生成空间刚好大小匹配就可以直接用，如果多了或者少了就不太适合使用了）
* 不会立即回收垃圾对象

### 标记整理算法实现原理

核心思想：标记整理可以看作是标记清除的增强。标记阶段的操作和标记清除一致，清除阶段会先执行整理，移动对象位置（让它们在地址上产生连续）。

<div style="text-align: center;">
  <img src="./assets/gc-mark-compact.png" alt="标记整理算法图示" style="width: 600px;">
  <p style="text-align: center; color: #888">（标记整理算法图示）</p>
</div>

标记整理算法优点：

* 减少碎片化空间

标记整理算法缺点：

* 不会立即回收垃圾对象

## V8 垃圾回收

### 认识 V8

V8 是一款主流的 JavaScript 执行引擎，日常使用的 Chrome 浏览器和目前的 Node.js 平台都采用这个引擎去执行 JavaScript 代码。因为 V8 采用即时编译，能将源代码直接翻译成可直接执行的机器码，所以速度非常快。

V8 对所能使用的内存空间进行了上限约束：64 位操作系统为 1.5GB，32 位操作系统为 800MB。

::: tip 为什么是 1.5GB 这个数值？
V8 最初是作为浏览器的 JavaScript 引擎而设计，所以对网页应用来说不太可能遇到大量内存的场景。  
V8 内部实现的垃圾回收机制，也决定了这个数值设定比较合理（V8 在执行垃圾回收时会阻塞 JavaScript应用逻辑，经官方测试，当垃圾内存达到 1.5GB 时，采用增量标记算法进行垃圾回收需要消耗 50ms，采用非增量标记算法进行垃圾回收需要消耗 1s，这样浏览器将在 1s 内失去对用户的响应，造成假死现象）。
:::

### V8 内存分配

V8 将内存（堆）空间一分为二，其中小空间用于存储新生代对象（64 位 - 32MB | 32 位 - 16MB），另一部分较大空间用于存储老生代对象（64 位 - 1.4GB | 32 位 - 700MB）。

::: tip 解释
新生代对象指的是存活时间较短的对象（例如局部作用域中的变量）。  
老生代对象指的是存活时间较长的对象（例如全局作用域下的变量、闭包中放置的变量）。
:::

<div style="text-align: center;">
  <img src="./assets/v8-memory-allocation.png" alt="V8 内存分配">
  <p style="text-align: center; color: #888">（V8 内存分配）</p>
</div>

### V8 垃圾回收策略

在 JavaScript 中的数据，分为基本数据类型和引用数据类型两种，其中基本数据类型由程序语言自身进行控制，V8 所进行的垃圾回收操作主要针对存在堆内存中的引用数据类型。

V8 采用分代回收的思想，将内存分为新生代、老生代。针对不同代的对象采用不同的 GC 算法进行回收。

V8 中常用的 GC 算法有：

* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 增量标记

### V8 如何回收新生代对象

* 采用复制算法 + 标记整理算法。
* 新生代内存区分为两个大小相等的空间：使用空间为 From，空闲空间为 To。
* 每当有新生对象诞生，就会在 From 空间出现。
* 一旦 From 空间被占满，就触发 GC。
* 对 From 空间的活动对象进行标记整理，然后将它们整个拷贝至 To。
* 清空 From 空间 （这样就可以实现把不活跃的对象给回收掉）。
* From 与 To 交换空间，开始下一轮循环。

注意点：

* 拷贝过程中可能出现晋升：将新生代对象移动至老生代存储区。
* 一轮 GC 结束还存活的新生代对象需要晋升。
* 拷贝时发现 To 空间的使用率超过 25%，则将本次拷贝对象直接移动至老生代存储区（25%：防止交换空间后，From 空间直接爆满，新的活动对象存不进去）。

### V8 如何回收老生代对象

* 主要采用标记清除、标记整理、增量标记算法
* 首先使用标记清除完成垃圾空间的回收（相对于空间碎片的问题，能够明显提升速度）
* 采用标记整理进行空间优化（新生代对象晋升时，如果老生代存储区空间不够，就触发标记整理）
* 采用增量标记进行效率优化

细节对比：

* 新生代区域垃圾回收使用空间换时间（复制算法导致每时每刻都会存在一个空闲空间）
* 老生代区域垃圾回收不适合复制算法（老生代存储空间较大，如果一分为二会浪费太多空间。且老生代存储空间会存储较多对象数据，如果进行复制操作会消耗过多时间。）

增量标记算法如何优化垃圾回收：

当垃圾回收开始工作的时候，会阻塞当前 JavaScript 程序的执行，于是就会产生「空档期」。增量标记算法能够将原本一整段的垃圾回收操作拆分成多个小步骤，从而替代原先一口气完成的垃圾回收操作，这样做可以让垃圾回收与程序执行交替工作。

如下图所示，当程序运行到某个时刻，触发垃圾回收机制。首先对老生代存储区的对象数据进行遍历，先找到第一层的可达对象，然后程序继续执行，接着对子元素（第二层可达对象）进行标记操作，接着程序继续执行，以此循环直到标记过程结束，最后完成垃圾回收操作后，程序继续执行。

<div style="text-align: center;">
  <img src="./assets/incremental-marking.png" alt="增量标记算法如何优化垃圾回收">
  <p style="text-align: center; color: #888">（增量标记算法如何优化垃圾回收）</p>
</div>

上述这个过程看似程序停顿了很多次，但整个 V8 最大的垃圾回收（达到 1.5GB）即使采用非增量标记的方式去回收也不会超过 1s。

## 垃圾