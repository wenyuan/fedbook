# MySQL 数据库设计规范

一个平台或系统随着时间的推移和用户量的增多，数据库操作往往会变慢。而在服务端开发中数据库更是尤为重要，绝大多数情况下数据库的性能决定了程序的性能，如若前期埋下的坑越多到后期数据库就会成为整个系统的瓶颈。因此，更规范化地使用 MySQL 在开发中是不可或缺的。

## 命名规范

* 数据库所有表前缀均使用系统或模块的英文名称缩写。
* 库名、表名、字段名必须使用小写字母并采用下划线分割。
* 库名、表名、字段名禁止超过 32 个字符，须见名知意。
* 库名、表名、字段名支持最多 64 个字符，统一规范、易于辨识以及减少传输量不要超过 32。
* 库名、表名、字段名禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）。
* 临时库、临时表名必须以系统或模块的英文名称缩写 + `_tmp_` 为前缀并以日期为后缀，例如（`pro_tmp_20220302`）。
* 备份库、备份表名必须以系统或模块的英文名称缩写 + `_bak_` 为前缀并以日期为后缀，例如（`pro_bak_20220302`）。
* 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。

## 基本设计规范

#### 1）若无特殊说明，建表时一律采用 InnoDB 存储引擎

选择合适的引擎可以提高数据库性能，如 InnoDB 和 MyISAM，InnoDB 和 MyISAM 是许多人在使用 MySQL 时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定；基本的差别为：MyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持；MyISAM 类型的表强调的是性能，其执行数度比 InnoDB 类型更快，但是不提供事务支持，而 InnoDB 提供事务支持以及外部键等高级数据库功能；因此，其支持事务处理、支持外键、支持崩溃修复能力和并发控制是我们建表时首选的存储引擎。

#### 2）数据库和表的字符集统一使用 `utf8mb4`（5.5.3 版本以上支持）

数据库和表的字符集统一使用 utf8，若是有字段需要存储 emoji 表情之类的，则将表或字段设置成 `utf8mb4`；因为，utf8 号称万国码，其无需转码、无乱码风险且节省空间，而 utf8mb4 又向下兼容 utf8。

#### 3）设计数据库时所有表和字段必须添加注释

使用 comment 从句添加表和列的备注，或直接在数据库连接工具的注释栏添加注释，从项目开始就进行数据字典的维护。

使用 comment 从句添加注释如：

```bash
# 创建表
CREATE TABLE t1(id varchar2(32) primary key,name VARCHAR2(8) NOT NULL,age number);
# 添加表注释
comment on table t1 is '个人信息';
# 添加字段注释：
comment on column t1.id is 'id';
comment on column t1.nameis '姓名';
comment on column t1.age is '年龄'; 
```

也可以使用可视化的数据库连接工具添加注释。

#### 4）单个表的数据量大小控制在 500 万以内

尽量控制单表数据量的大小，建议控制在 500 万以内。500 万并不是 MySQL 数据库的极限，但数据量太多不利于对表结构进行修改、备份和恢复数据。

可以适当采用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制单表数据量的大小。

#### 5）谨慎使用 MySQL 分区表

业务生命周期内，评估单表数据量是否在 500 万以内，超出此范围需考虑分库分表可扩展性。

分区是将一个表的数据按照某种方式，比如按照时间上的月份，分成多个较小的，更容易管理的部分，但是逻辑上仍是一个表。分区表在物理上表现为多个文件，在逻辑上仍表现为同一个表，需要谨慎选择分区键。跨分区查询效率可能会更低，建议使用物理分区表等方式管理大数据。

#### 6）尽量做到冷热数据分离，减小表的宽度

MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不超过 65535 字节，为了减少磁盘 IO 线程的开销，就要适当控制表的宽度，因为表越宽，把表装载进内存缓冲池时所占用的内存也就越大，就会消耗更多的 IO 线程。除此之外，为了保证热数据的内存缓存命中率，更有效的利用缓存，避免读入无用的冷数据，尽量把经常使用到的列放到同一个表中，避免不必要的关联操作。

#### 7）建立预留字段需谨慎

部分开发者在设计数据库表时，不仅设计了当前所需要的字段，而且还在其中留出几个字段作为备用。比方说，我设计了一个人员表（person），其中已经添加了各种必要的字段，包括姓名（Name）、性别（Sex）、出生年月日（birthday）等等；为了以防万一，比如之后可能 Person 表会涉及到毕业院校、工作单位、是否婚配和相片等信息，于是就加入 5 个 varchar2 型的字段，分别叫做 text1、text2……text5。

这一手操作看似防范于未然，其实也并不见得，因为大量预留字段会浪费空间、预留字段不能做到见名知意、预留字段无法确认存储的数据类型且修改其字段类型还可能会造成锁表等问题。

针对此等情况可以参考以下两点解决方案：

* 如果数量很少，而且信息的性质与原表密切相关，那么就可以直接在原表上增加字段，并将相关的数据更新进去。
* 如果数量较大，或者并非是原表对象至关重要的属性，那么就可以新增一个表，然后通过键值连接起来。

#### 8）数据库中禁止存储图片、文件等大的二进制数据

若往数据库表中存储文件，而文件通常很大，当数据库进行读取操作时，会进行大量的随机 IO 操作，大文件使得 IO 操作很耗时耗性能，造成短时间内数据量快速增长。所以，通常将图片、文件存储在文件服务器中，数据库只用于存储文件地址信息。

#### 9）禁止在线上做数据库压力测试

#### 10）禁止从开发环境，测试环境直接连接生成环境数据库

## 字段设计规范

#### 1）优先选择符合存储需要的最小的数据类型

主要是考虑索引的性能，因为列的字段越大，建立索引时所需要的空间也越大，这样一页中能存储的索引节点的数量也就越少，在遍历时需要的 IO 次数也就越多，索引的性能也就越差。

建议：

* 将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据。
* 对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储。因为，无符号相对于有符号可以多出一倍的存储空间，VARCHAR(N) 中的 N 代表的是字符数，而不是字节数。使用 UTF8 存储 255 个汉字，Varchar(255)=765 个字节。过大的长度会消耗更多的内存。
                                         
#### 2）避免使用 TEXT、BLOB 数据类型

最常见的 TEXT 类型可以存储 64K 数据，MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，若查询中包含这样的数据，在执行排序等操作时就不能使用内存临时表，必须使用磁盘临时表执行操作。

但是不是说一定不能使用这样的数据类型，如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 `select *` 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。

注意：出于内存和性能考虑，MySQL 对索引字段长度是有限制的。所以 TEXT 或 BLOB 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。

#### 3）避免使用 ENUM 枚举类型

* 修改 ENUM 值需要使用 `ALTER` 语句。
* ENUM 类型的 `ORDER BY `操作效率低。
* 禁止使用数值作为 `ENUM` 的枚举值。

#### 4）尽可能把所有列定义为 NOT NULL

* 如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引，索引统计和值比较都更复杂（在 where 子句中对字段进行 null 值判断，将导致引擎放弃使用索引而进行全表扫描）。
* 含 NULL 复合索引无效。
* 可为 NULL 的列会使用更多的存储空间，在 MySQL 中也需要特殊处理。
* 当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。

通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以（调优时）没有必要首先在现有 schema 中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。

#### 5）使用 TIMESTAMP（4 字节）或 DATETIME（8 字节）类型存储时间

TIMESTAMP 存储的时间范围为：1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。

TIMESTAMP 占用 4 字节和 INT 相同，但可读性比 INT 类型的高，同时 TIMESTAMP 具有自动赋值以及自动更新的特性。若是超出 TIMESTAMP 取值范围的则使用 DATETIME 类型存储。

用字符串类型存储时间的缺点：无法使用日期函数进行比较计算、字符串存储占有更多的空间。

#### 6）财务相关的金额类数据必须使用 DECIMAL 类型

* 精准浮点：DECIMAL
* 非精准浮点：FLOAT、DOUBLE

DECIMAL 类型为精准浮点数，在计算时不会丢失精度。占有空间大小由定义的宽度决定，每 4 个字节可以存储 9 位数字，且小数点也要占有一个字节。另外，DECIMAL 类型可用于存储比 BIGINT 更大的数据类型。

#### 7）建议使用 UNSIGNED 存储非负数值

同样的字节数，非负存储的数值范围更大。如 TINYINT 有符号为 -128-127，无符号为 0-255。

#### 8）建议使用 INT UNSIGNED 存储 IPV4

用 UNSINGED INT 存储 IP 地址占用 4 字节，CHAR(15) 则占用 15 字节。另外，计算机处理整数类型比字符串类型快。使用 INT UNSIGNED 而不是 CHAR(15) 来存储 IPV4 地址，通过 MySQL 函数 `inet_ntoa` 和 `inet_aton` 来进行转化。IPv6 地址目前没有转化函数，需要使用 DECIMAL 或两个 BIGINT 来存储。

例如：

```bash
SELECT INET_ATON('209.207.224.40'); # 3520061480
SELECT INET_NTOA(3520061480);       # 209.207.224.40
```

#### 9）建议使用 TINYINT 来代替 ENUM 类型

ENUM 类型在需要修改或增加枚举值时，需要在线 DDL，成本较高。且 ENUM 列值如果含有数字类型，可能会引起默认值混淆。

#### 10）使用 VARBINARY 存储大小写敏感的变长字符串或二进制内容

VARBINARY 默认区分大小写，没有字符集概念，速度快。

#### 11）禁止在数据库中存储明文密码

## 索引设计规范

建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。

索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。

#### 1）每张表的索引数量不超过 5 个

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。

#### 2）禁止给表中的每一列都建立单独的索引

5.6 版本之前，一个 SQL 只能使用到一个表中的一个索引；5.6 以后，虽然有了合并索引的优化方式，但远没有使用联合索引的查询方式效率高。

#### 3）每个 InnoDB 表必须有一个主键

InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。

每个表都可以有多个索引，但是表的存储顺序只能有一种，InnoDB 是按照主键索引的顺序来组织表的，因此不要使用更新频繁的列、UUID、MD5、HASH 和字符串列作为主键，这些列无法保证数据的顺序增长，主键建议使用自增 ID 值。

#### 4）使用短索引

对字符串使用前缀索引，前缀索引长度不超过 10 个字符。

举例：如有一个 CHAR(200) 列，在前 10 个字符内，多数值是惟一的，就可不要对整个列进行索引。只对前 10 个字符进行索引能够节省大量索引空间，也可能会使查询更快。

#### 5）避免冗余或重复索引

合理创建联合索引（避免冗余），index(a,b,c) 相当于 index(a)、index(a,b)、index(a,b,c)。

* 索引不是越多越好，按实际需要进行创建，每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。
* 不在低基数列上建立索引，例如「性别」。
* 不在索引列进行数学运算和函数运算。

#### 6）尽量避免使用外键约束

* 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引。
* 外键虽然可以保证数据的参照完整性，但外键也会影响父表和子表的写操作从而降低性能，还会使得表更耦合，建议在业务端实现。

#### 7）不使用 `%` 前导的查询，如 `like "%xxx"`

无法使用索引。

#### 8）不使用反向查询，如 `not in` / `not like`

无法使用索引，导致全表扫描，全表扫描导致 bufferpool 利用降低。

#### 9）索引列建议

① 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列

② 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段。

③ 多表 join 的关联列。

注意：并不要将符合 ① 和 ② 中的字段的列都建立一个索引，通常将 ①、② 中的字段建立联合索引效果更好。

#### 10）如何选择索引列的顺序

* 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）。
* 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）。
* 使用最频繁的列放到联合索引的左侧（这样可较少的建立一些索引）。

#### 11）避免建立冗余索引和重复索引

冗余/重复索引会增加查询优化器生成执行计划的时间。

* 重复索引示例：primary key(id)、index(id)、unique index(id)
* 冗余索引示例：index(a,b,c)、index(a,b)、index(a)

#### 12）优先考虑覆盖索引

对于频繁的查询优先考虑使用覆盖索引。

覆盖索引：即包含了所有查询字段（where，select，order by，group by 包含的字段）的索引。

覆盖索引的好处：

* 避免 InnoDB 表进行索引的二次查询
  * InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。
  * 而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。
* 可以把随机 IO 变成顺序 IO 加快查询效率
  * 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

## SQL 编写规范

#### 1）建议使用预编译语句进行数据库操作

预编译语句可以重复使用，相同的 SQL 语句可以一次解析，多次使用，减少 SQL 编译所需要的时间，提高处理效率；此外，还可以有效解决动态 SQL 带来的 SQL 注入问题。

#### 2）避免数据类型的隐式转换

隐式转换如：`SELECT 1 + "1"`。数值型 + 字符型 的隐式转换有可能会导致索引失效，以及一些意想不到的结果等。

#### 3）充分利用表中存在的索引

* 避免使用双 `%` 号的查询条件
  * 如 `WHERE first_name like '%James%'`，若无前置 `%`，只有后置 `%`，则执行 SQL 语句时会用到列上的索引，双 `%` 号则不会使用列上的索引。
* 一条 SQL 语句只能使用复合索引中的一列进行范围查询
  * 例如有 weight、age、sex 三列的联合索引，在查询条件中有 weight 列的范围查询，则在 age 和 sex 列上的索引将不会被使用。因此，在定义联合索引时，若某列需要用到范围查询，则将该列放到联合索引的右侧。
* 使用 `not exists` 代替 `not in`
  * 因为 `not in` 在 SQL 语句中执行时会导致索引失效。

#### 4）杜绝使用 `SELECT *` ，必须使用 `SELECT <字段列表>` 查询

因为使用 `SELECT *` 查询会消耗更多的 CPU、IO 和网络宽带资源，并且查询时无法使用覆盖索引。

#### 5）禁止使用不含字段列表的 `INSERT` 语句

如：`INSERT into table_name values ('1','2','3');` 

改为带字段列表的 INSERT 语句：`INSERT into table_name('c1','c2','c3') values ('1','2','3');`

#### 6）避免使用子查询，可以把子查询优化为 `join` 关联操作

但是，通常子查询在 `in` 子句中，且子查询中为简单 SQL（即不包含 `union`、`group by`、`order by`、`limit` 从句）时，才可以把子查询转化为 `join` 关联查询进行优化。

子查询性能差的原因：

* 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。
* 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

#### 7）避免使用 `JOIN` 关联太多表

* 在 MySQL 中，对于同一个 SQL 关联（join）多个表，每个 `join` 就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。
* 如果程序中大量的使用了多表关联的操作，同时 `join_buffer_size`（MySQL 允许关联缓存的个数）设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响服务器数据库性能的稳定性。
* 此外，对于关联操作来说，会产生临时表影响查询效率，而 MySQL 最多允许关联 61 个表，建议不超过 5 个。

#### 8）对同一列对象进行 `or` 判断时，使用 `in` 替代 `or`

`in` 的值只要涉及不超过 500 个，则 `in` 操作可以更有效的利用索引，`or` 大多数情况下很少能利用到索引。

#### 9）禁止使用 `order by rand()` 进行随机排序

随机排序会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。

简单来说：`order by rand()` 会将数据从磁盘中读取，进行排序，会消耗大量的 IO 和 CPU。

推荐在程序中获取一个随机值，然后从数据库中获取对应的数据。

#### 10）禁止在 `WHERE` 从句中对列进行函数转换和计算

因为在 `WHERE` 从句中对列进行函数转换或计算时会导致索引无法使用。

```bash
# 不推荐
where date(end_time)='20190101'

# 推荐
where end_time >= '20190101' and end_time < '20190102'
```

#### 11）在明显不会有重复值时使用 `UNION ALL` 而不是 `UNION`

* `UNION` 会把两个结果集的所有数据放到临时表中后再进行去重操作。
* `UNION ALL` 不会再对结果集进行去重操作。

#### 12）把复杂、较长的 SQL 拆分为多个小 SQL 执行

* 大 SQL 在逻辑上比较复杂，是需要占用大量 CPU 进行计算一条 SQL 语句。
* 在 MySQL 中，一条 SQL 语句只能使用一个 CPU 进行计算。
* SQL 拆分后可以通过并行执行来提高处理效率。

#### 13）避免在数据库中进行数学运算

* 容易将业务逻辑和 DB 耦合在一起
* MySQL 不擅长数学运算和逻辑判断
* 无法使用索引

## 数据操作规范

#### 1）超过100万行数据的批量操作（update delete insert），分多次进行

* 大批量操作可能回造成严重的主从延迟。
  * 主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，只有当主库上执行完成后，才会在其他从库上执行，会造成主库与从库长时间的延迟情况。
* binlog 日志为 row 格式时会产生大量的日志。
  * 大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，一次修改的数据越多，产生的日志量也会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。
* 避免产生大事务操作。
  * 大批量修改数据，一定是在一个事务中进行的，这会造成表中大批量数据进行锁定，导致大量的阻塞，阻塞会对 MySQL 的性能影响很大。尤其是长时间的阻塞会占满所有数据库的可用连接，会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。

#### 2）对于大表使用 pt-online-schema-change 修改表结构

* 可避免大表修改产生的主从延迟。
* 可避免在对表字段进行修改时进行锁表

生产环境中，对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。

> pt-online-schema-change 它首先会建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。
>
> 接着，把原表中新增的数据也复制到新表中，在将所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉，其实是把原来一个 DDL 操作，分解成多个小的批次执行。
>
> 这也是对表进行碎片整理/重组的一个常用方式。

#### 3）禁止给程序使用的账号授予 super 权限

原因：当 MySQL 达到最大连接数限制时，此刻还运行 1 个有 super 权限的用户连接，super 权限只能留给 DBA 处理问题的账号使用。

#### 4）对于程序连接数据库账号，遵循权限最小原则

程序使用数据库账号只能在一个数据库下使用，不准跨库，且程序使用的账号原则上不授予 drop 权限。

#### 5）其他一些操作规范

* 任何数据库的线上操作，必须走工单。
* 禁止在主库上执行统计类的功能查询。
* 有大规模市场推广、运营活动必须提前通知 DBA 进行流量评估。
* 对单表的多次 `alter` 操作必须合并为一次操作。
* 不在 MySQL 数据库中存放业务逻辑，即可创建存储过程。
* 重大项目的数据库方案选型和设计必须提前通知 DBA 参与。
* 数据必须有备份机制和定期的恢复演练。
* 不在业务高峰期批量更新、查询数据库。

（完）
